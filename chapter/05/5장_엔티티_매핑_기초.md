# 📕 엔티티 매핑 기초
작성자: 한창훈

---

# 📜 엔티티 매핑이 필요한 이유

ORM을 사용하는 이유는 RDB를 사용하더라도 RDB에 종속되지 않고 객체지향적으로 개발하기 위함이다.

JPA를 사용하게 되면 이때 DB 테이블과 매핑한 객체를 사용하여 객체지향 프로그래밍을 하게 된다.

즉, 실제로 개발자는 일반 객체를 사용하듯이 개발을 하지만 `@Entity`가 붙은 객체는 실제로 데이터베이스를 조작하게 된다.

따라서 엔티티 매핑 혹은 연관관계 매핑이라 불리는 이 행위를 제대로 해야만 데이터베이스에 데이터가 원하는대로 조작된다.

엔티티 매핑을 제대로 하지 않을 경우 데이터가 예상과 다르게 저장되거나, 삭제되는 사고가 발생하며

쿼리도 예상과 다르게 발생하는 경우가 많아지는 둥 전체적으로 효율이 떨어지게 된다.

---

# 📜 단방향, 양방향 연관관계

팀(Team)과 선수(Member)객체가 있다고 치자.

이 경우 팀에는 여러명의 선수가 속할 수 있고(일대다)

선수 입장에서는 한 선수가 한 팀에만 소속될 수 있다.(다대일)

이를 일반적인 객체로 표현하면 아래와 같이 된다.

```java
public class Team{
    private String name;
    private Set<Member> members;
}

public Member{
    private String name;
    private Integer age;
    private Team team;
}
```

이처럼 팀(Team)에서 선수(Member)를 참조할 수 있고, 선수(Member)에서 팀(Team)을 참조할 수 있는 구조를

`양방향 관계`라고 부른다. 정확히는 일대다, 다대일의 `단방향 관계`가 두개 있는 것이다.

하지만 이러한 양방향 관계는 대체적으로 좋지 않은데, 일반적으로 실무에서는 최대한 제약을 가하는 방향으로 개발을 하기 때문에

이와 반대되는 방향의 개발방법이기 때문이다.

왜 제약적으로 개발하느냐? 라는 의문이 들 수 있다. 

우선 현업에서는 혼자서만 개발하는게 아니고 팀원들과 함께 개발하는데 어떤 로직에 대해 해당 로직을 개발한 당사자는 어떤 로직을 사용하면 되고

어떤 로직을 사용하면 안되는지 남들보다 잘 알 수밖에 없다. 

하지만 팀 동료입장에서는 어떤 로직을 사용하면 되고 어떤 로직을 사용하면 안되는지 정확하게 알 수 없기 때문에 코드레벨에서 최대한 제약을 두게되면

해당 로직을 사용하는 동료가 컴파일 에러들을 보게될 경우 개발자가 어떠한 의도가 있어서 해당 로직을 막아두었음을 짐작할 수 있게 된다.


<br />

둘째로 객체간 결합도가 높아진다.

객체지향 프로그래밍에서 가장 중요하게 여겨야 할 개념이 두가지 있다.

***응집도는 높게, 결합도는 낮게***

객체 참조를 한다는 것은 해당 객체들간에 결합도가 생김을 의미하므로 좋지 않다.

이로인해 발생하는 문제로 `디미터 법칙`을 위반하는 사례를 들 수 있다.

디미터 법칙은 [Object-Oriented Programming: An Objective Sense of Style](https://dl.acm.org/doi/10.1145/62084.62113) 에서 소개된 개념인데,

이해하기 쉽게 요약하자면 ***한줄에 점(.)은 하나만 찍는다*** 로 요약할 수 있다.

즉 위와 같은 양방향 매핑 코드의 경우 아래와 같은 코딩이 가능해진다.

```java
member.getTeam().getMembers().get(0).getTeam()....
```

위와 같은 코드를 실제로 쓰건 안쓰건 위와 같은 방식의 코딩을 그 누구라도 언제든지 시도할 수 있다는 것은 매우 좋지 않은상황이며

우선 코드를 보는 동료를 매우 혼란스럽게 만들고, 객체간 결합도가 높아짐으로 인해 코드를 수정할 때 어떤 사이드 이펙트가 발생할 지 예측하기 힘들어진다.

<br />

필자는 실무를 보면서 양방향 관계를 절대적으로 사용하지 않으려 하며, 정말로 필요하다고 생각될 경우에만 제한적으로 사용을 고려한다.

대부분의 업무가 단방향 매핑으로 충분히 해결이 되며, 가급적이면 단방향 매핑도 쓰지 않는게 좋다고까지 생각한다.

JPA를 공부한다면 추후 `QueryDSL`까지 공부하게 될 확률이 매우 높기 때문에 이러한 단방향, 양방향 관계에 대해 너무 고민할 필요는 없다고 생각하는 편이다.

그냥 이런것도 있구나 알아두고, 기억할 것은 가급적 양방향은 사용을 자제하고, 최대한 단방향으로만 개발하도록 노력해본다는 것.

만약 본인이 `QueryDSL`을 사용할 줄 안다면 단방향 매핑도 크게 중요하지 않을 수 있다고 생각한다.

---

# 📜 연관관계의 주인

RDB의 테이블과 Java 객체의 차이에 대한 이해가 필요하다.

RDB의 경우 외래키(FK)로 테이블끼리 관계를 맺는데 테이블이 두개 있다고 가정하면 둘중 어느 테이블이든 FK가 하나 존재하면

`inner join`, `outer join` 등으로 언제든지 양방향 참조가 쉽게 가능하다.

하지만 Java 객체의 경우엔 양방향 참조를 위해서는 각 객체에 참조를 위한 클래스변수가 반드시 필요하다.

위의 코드를 다시 가져와보자면,

```java
public class Team{
    private String name;
    private Set<Member> members;
}

public Member{
    private String name;
    private Integer age;
    private Team team;
}
```

이처럼 팀(Team) 객체에서는 Set<Member> members 필드를 통해 선수(Member) 객체를 참조하고 있으며

선수(Member) 객체에서는 팀(Team) 객체를 참조하기 위해 Team team 필드를 사용한다.

이러한 차이로 인해 객체관점에서 이러한 동등한 위치의 단방향 관계가 서로를 향하게 되면 DB 입장에서는 어느 객체가 외래키(FK)를 관리하는지

알 수 없기 때문에 이를 명시해줘야 하게 된다.

이를 연관관계의 주인이라 부르며, 쉽게 생각하면 둘중 어느 객체가 외래키(FK)를 관리하는가의 문제라고 볼 수 있다.

일반적으로 DBA분들이 RDB를 설계-구축하실 때 다대일 관계에서 자식(다) 쪽에 외래키(FK)를 두게 설계하기 때문에

JPA를 사용하며 엔티티 매핑을 할 때 이를 따라가게 된다.

큰 문제를 발생시키기 싫다면 법칙이라고 생각해도 좋다. RDB에서 외래키(FK)가 위치한 테이블과 매핑한 객체를 연관관계의 주인으로 지정하자.

코드는 아래와 같다.

```java
@Entity
public class Team {
    @Id
    private Long id;
    private String name;

    @OneToMany(mappedBy = "team")
    private Set<Member> members = new HashSet<>();
}

@Entity
public class Member {
    @Id
    private Long id;
    private String name;
    private Integer age;
    
    @ManyToOne
    private Team team;
}
```

이처럼 `mappedBy`를 사용하여 본인이 연관관계의 주인이 아님을 알리고, 연관관계의 주인인 필드명을 명시해 JPA에 알려주면 된다.

```java

    /** 
     * (Optional) The field that owns the relationship. 
     * This element is only specified on the inverse (non-owning) side of the association.
     * 
     * 연관관계의 주인인 필드를 지정한다.
     * 이 요소는 연관관계의 주인이 아닌 쪽에서만 사용한다.
     */
    String mappedBy() default "";
```

이 연관관계의 주인이 중요한 개념인 이유는 

연관관계의 주인이 아닌곳에서 데이터를 조작하고 영속성 컨텍스트에 반영할 경우

외래키(FK)가 제대로 업데이트 되지 않는다는 것에 있다.

코드를 제대로 작성했는데 데이터가 저장이 안되요, 업데이트가 안되요 하는 사례들이 있으며

이러한 문제들은 십중팔구 연관관계의 주인이 아닌 곳에서 데이터를 조작하여 발생한 경우이다.

---

# 📜 연관관계 편의 메서드

양방향 매핑을 한다는 것은 객체 참조를 하겠다는 의미이므로

객체 입장에서는 양쪽에 모두 객체를 설정해주는게 맞다.

하지만 연관관계 편의 메서드가 없을 경우 본인이나 동료 개발자가 양쪽 객체에 모두 설정하는 작업을 모두 수작업으로 해줘야 하기 때문에

이러한 작업이 누락되는 휴먼에러가 발생할 확률이 높아진다.

양방향 매핑시 이런 문제를 방지하기 위해 연관관계 편의 메서드를 작성하게 된다.

```java
Team team = new Team("name");
em.persist(team);

Member member = new Member("name", 20);
member.setTeam(team);
em.persist(member);
```

위 코드에서 팀(Team) 객체는 연관관계의 주인이 아니므로 따로 설정을 해주지 않아도 된다.

어차피 안해도 되는게 해봤자 DB상에는 데이터 적용이 무시된다.

하지만 위 코드의 경우 팀(Team) 객체에서는 선수(Member) 객체를 제대로 탐색할 수 없다.

따라서 이를 방지하기 위해 아래와 같은 코드를 따로 작성해준다.

```java
team.getMembers().add(member);
```

하지만 이러한 코드를 매번 작성해줘야 하기 때문에 누락 될 여지가 높으며

이를 방지하기 위해 수정자를 약간 변형해준다. 

이를 연관관계 편의 메서드라고 부른다.

```java
@Entity
public class Team {
    @Id
    private Long id;
    private String name;

    @OneToMany(mappedBy = "team")
    private Set<Member> members = new HashSet<>();
    
    public joimMember(Member member){
        this.members.add(member);
        member.changeTeam(this);
    }
}

@Entity
public class Member {
    @Id
    private Long id;
    private String name;
    private Integer age;
    
    @ManyToOne
    private Team team;
    
    public changeTeam(Team team){
        if(this.team != null) {
            this.team.getMembers().remove(this); // 혹시모를 버그를 방지하기 위해 연관관계를 초기화
        }
        this.team = team;
        this.team.getMembers().add(this);
    }
}
```

위의 코드를 사용하게 되면 아래와 같이 된다.

```java
Team team = new Team("name");
em.persist(team);

Member member = new Member("name", 20);
member.changeTeam(team);
em.persist(member);

// team.getMembers().add(member); 이 누락되도 상관 없음.
```

혹은 반대로도 사용 가능하다.

```java
Team team = new Team("name");
Member member = new Member("name", 20);
team.joinMember(member);
em.persist(team);
em.persist(member);
```

하지만 더 좋은 것은 애초에 이런 양방향 관계를 설정하지 않는 것임을 알아두자 !

